#!/usr/bin/env python
#
# This file is part of ravstack. Ravstack is free software available under
# the terms of the MIT license. See the file "LICENSE" that was provided
# together with this source file for the licensing terms.
#
# Copyright (c) 2015 the ravstack authors. See the file "AUTHORS" for a
# complete list.

# This file has no dependencies outside the Python standard library. It should
# work with any Python 2.7.x and 3.3+.

"""Find public endpoint for a local service under portmapping."""

from __future__ import absolute_import, print_function

import os
import sys
import time
import errno
import socket
import select
import struct
import logging
import argparse
import subprocess
import tempfile
import httplib
import json

portmap_base = 10000
portmap_nports = 50
portmap_cache = '/etc/ravello/ports.json'

DEBUG = False


def setup_logger():
    """Set up a basic logger."""
    logger = logging.getLogger()
    handler = logging.StreamHandler(sys.stderr)
    handler.setFormatter(logging.Formatter('%(levelname)s [%(name)s] %(message)s'))
    logger.addHandler(handler)
    logger.setLevel(logging.ERROR)
    return logger

LOG = setup_logger()


def get_public_ip():
    """Get my public IP."""
    # This uses ipify.org. See www.ipify.org. This is a free, unlimited service
    # running on Heroku so we can probably trust it.
    conn = httplib.HTTPConnection('api.ipify.org', 80)
    try:
        conn.request('GET', '/')
        resp = conn.getresponse()
        if resp.status != httplib.OK:
            raise RuntimeError('api.ipify.org status {}'.format(resp.status))
        body = resp.read()
    finally:
        conn.close()
    return body


def inet_atoni(ip):
    """Like inet_aton() but returns an integer."""
    return struct.unpack('>I', socket.inet_aton(ip))[0]

def inet_nitoa(i):
    """Like inet_ntoa but expects an integer."""
    return socket.inet_ntoa(struct.pack('>I', i))


def find_in_connection_table(addr):
    """Find a peer address *addr* in the connection table, and return the
    socket address."""
    # Addresses in /proc/net/tcp are network endian printed as machine endian,
    # meaning they get byte swapped on little endian. Ports are machine endian
    # printed as machine endian i.e. never byte swapped.
    peer_addr = '{:08X}:{:04X}'.format(socket.ntohl(inet_atoni(addr[0])), addr[1])
    sock_addr = None
    with open('/proc/net/tcp') as fin:
        for line in fin:
            parts = line.split()
            if parts[2] == peer_addr:
                sp = parts[1].split(':')
                sock_addr = (inet_nitoa(socket.htonl(int(sp[0], 16))), int(sp[1], 16))
                break
    return sock_addr


def find_mapped_port(port, publicip, timeout, low, hi):
    """Find the port on public IP *publicip* that is mapped to a local service
    listening on *port*."""
    # The approach: we know that Ravello maps ports starting at a fixed port.
    # We simply try a number of ports start at that port and try to connect to
    # it. If we can connect, see if the socket connects back to the service we
    # are interested in.
    #
    # A limitation of this approach is that it only supports ports that are
    # listening.
    #
    # Ravello, we really need an API for this that can be executed from within
    # a VM without having to store credentials...

    # First do a non-blocking connect on all candidate ports in parallel.
    sockets = {}
    for cport in range(low, hi):
        sock = socket.socket()
        sock.setblocking(False)
        try:
            sock.connect((publicip, cport))
        except socket.error as e:
            if e.args[0] != errno.EINPROGRESS:
                sock.close()
                continue
        LOG.debug('Non-blocking connect to {}:{}'.format(publicip, cport))
        sockets[sock.fileno()] = (sock, cport)

    # Select loop where we wait for *timeout* seconds for the sockets to
    # connect. Once connect, we try to find the peer socket in /proc/net/tcp.
    # Note that we may not find it because the port may map to a different VM.

    publicport = None
    end_time = time.time() + timeout

    while True:
        timeout = end_time - time.time()
        if timeout < 0:
            break
        fds = [sock.fileno() for sock, _ in sockets.values()]
        try:
            _, wfds, _ = select.select([], fds, [], timeout)
        except select.error as e:
            if e.args[0] == errno.EINTR:
                continue
            raise
        for fd in wfds:
            sock, cport = sockets[fd]
            try:
                error = sock.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)
                if error:
                    LOG.debug('Socket to port {} errno {}'.format(cport, error))
                    raise socket.error(error)
                LOG.debug('Socket to port {} got connected'.format(cport))
                paddr = (publicip, sock.getsockname()[1])
                saddr = find_in_connection_table(paddr)
                LOG.debug('Found in connection table: {!r}'.format(saddr))
                if saddr and saddr[1] == port:
                    publicport = cport
            except socket.error:
                pass
            sock.close()
            del sockets[fd]
        if publicport or not sockets:
            break

    # Clean up remaining sockets and return the result.
    for sock, _ in sockets.values():
        sock.close()
    sockets.clear()

    if publicport is None:
        raise RuntimeError('Could not find mapped port for service `{}`.'.format(port))
    return publicport


def try_unlink(fname):
    """Try to unlink a file but do not raise an error if the file does not
    exist."""
    try:
        os.unlink(fname)
    except OSError as e:
        if e.errno != errno.ENOENT:
            raise


def load_cache():
    """Load the port mapping cache."""
    try:
        with open(portmap_cache) as fin:
            return json.loads(fin.read())
    except IOError as e:
        if e.errno == errno.ENOENT:
            return {}
        raise


def update_cache(cache):
    """Update the port mapping cache."""
    fd, tmpname = tempfile.mkstemp(dir=os.path.split(portmap_cache)[0])
    try:
        with os.fdopen(fd, 'w') as fout:
            fout.write(json.dumps(cache, sort_keys=True, indent=2))
            fout.write('\n')
        os.chmod(tmpname, 0o644)
        os.rename(tmpname, portmap_cache)
    finally:
        try_unlink(tmpname)


def create_parser():
    """Create the command-line parser."""
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('port', type=int, help='the local service listening port')
    parser.add_argument('-d', '--debug', action='store_true', help='enable debugging')
    parser.add_argument('-t', '--timeout', type=int, default=2,
                        help='total time in seconds for scan')
    parser.add_argument('-c', '--use-cache', action='store_true',
                        help='use and maintain cache at {}'.format(portmap_cache))
    parser.add_argument('-b', '--base', type=int, default=portmap_base,
                        help='base port to start scanning at')
    parser.add_argument('-n', '--nports', type=int, default=portmap_nports,
                        help='number of ports to try starting at base')
    return parser


def main():
    """Main program."""
    parser = create_parser()
    args = parser.parse_args()

    global DEBUG
    DEBUG = args.debug
    if DEBUG:
        LOG.setLevel(logging.DEBUG)

    publicip = get_public_ip()
    LOG.debug('my public IP: `{}`.'.format(publicip))

    publicport = None
    candidate = None

    if args.use_cache:
        cache = load_cache()
        addr = cache.get(str(args.port))
        if addr:
            candidate = addr[1]

    if candidate:
        publicport = find_mapped_port(args.port, publicip, args.timeout,
                                      candidate, candidate+1)

    if publicport is None:
        publicport = find_mapped_port(args.port, publicip, args.timeout,
                                      args.base, args.base + args.nports)
    
    if publicport is None:
        LOG.debug('Public port for service `{}` not found.'.format(args.port))
        sys.exit(1)

    if args.use_cache:
        cache[str(args.port)] = (publicip, publicport)
        update_cache(cache)

    print('{}:{}'.format(publicip, publicport))


if __name__ == '__main__':

    if not sys.platform.startswith('linux'):
        raise RuntimeError('This program works only on Linux.')

    try:
        main()
    except Exception as e:
        if DEBUG:
            raise
        LOG.error(str(e))
